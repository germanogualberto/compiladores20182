/*
 * generated by Xtext 2.15.0
 */
package org.xtext.example.pascal.validation

import java.util.Map
import java.util.HashMap
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.xtext.example.pascal.pascal.PascalPackage
import org.xtext.example.pascal.pascal.any_number
import org.xtext.example.pascal.pascal.assignment_statement
import org.xtext.example.pascal.pascal.block
import org.xtext.example.pascal.pascal.expression
import org.xtext.example.pascal.pascal.factor
import org.xtext.example.pascal.pascal.function_designator
import org.xtext.example.pascal.pascal.abstraction_declaration
import org.xtext.example.pascal.pascal.program
import org.xtext.example.pascal.pascal.record_section
import org.xtext.example.pascal.pascal.simple_expression
import org.xtext.example.pascal.pascal.term
import org.xtext.example.pascal.pascal.type
import org.xtext.example.pascal.pascal.type_definition
import org.xtext.example.pascal.pascal.number
import org.xtext.example.pascal.pascal.constant
import org.xtext.example.pascal.pascal.variable
import org.xtext.example.pascal.pascal.variable_section
import org.xtext.example.pascal.pascal.while_statement
import org.xtext.example.pascal.pascal.statement_sequence
import org.eclipse.xtext.parser.packrat.tokens.AssignmentToken.End
import java.util.List

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PascalValidator extends AbstractPascalValidator {
	
	public static final Map<String, Map<String, Object>> artefacts = new HashMap<String, Map<String, Object>>();
	
	private var variables = new HashMap<String, variable_section>();
	private var records = new HashMap<String, record_section>();
	private var types = new HashMap<String, type_definition>();
	private var functions = <String, abstraction_declaration>newHashMap();
	
	@Check
	def fillArtefacts(program p) {
		var name = p.heading.name;
		if (!artefacts.containsKey(name)) {
			artefacts.put(name, new HashMap<String, Object>());
			artefacts.get(name).put("variables", variables);
			artefacts.get(name).put("functions", functions);
			artefacts.get(name).put("records", records);
			artefacts.get(name).put("types", types);
		}
	}
	
	@Check
	def checaVariavelDeclaradaSemInicializar(variable_section varDecl) {
		if (!varDecl.identifiers.names.isNullOrEmpty()){
			for (String element : varDecl.identifiers.names) {
				if (!variables.containsKey(element)) {
					variables.put(element, varDecl)
				} else {
					error("Duplicate identifier "+element, null);
				}
			}
		}
	}
	
	@Check
	def checaRegistroDeclaradoSemInicializar(record_section r) {
		if (!r.identifiers.names.isNullOrEmpty()){
			for (String element : r.identifiers.names) {
				if (!records.containsKey(element)) {
					records.put(element, r)
				} else {
					error("Duplicate identifier "+element, null);
				}
			}
		}
	}
	
	@Check
	def checaTipoDuplicado(type_definition t) {
		if (t.name !== null){
			if (!types.containsKey(t.name)) {
				types.put(t.name, t)
			} else {
				error("Duplicate identifier "+t.name, null);
			}
		}
	}
	
	@Check
	def checaFuncDecl(abstraction_declaration abt) {
		if (abt.heading !== null && !functions.containsKey(abt.heading.name)) {
			functions.put(abt.heading.name, abt)
		} else {
			error("Duplicate identifier "+abt.heading.name, null)
		}
		
		if (abt.heading.returnType !== null) {
			if (abt.block.statement === null || abt.block.statement.sequence === null) {
				error("Function needs return", null)
			}
		}
	}
	
	@Check
	def checaFuncCall(function_designator call) {
		if (!functions.containsKey(call.name)) {
			error("Identifier not found " + call.name, null);
		} else if (call.expressions.expressions.size !== functions.get(call.name).heading.parameters.parameters.size) {
			error("Wrong number of parameters specified for call to " + call.name, null)
		}
	}
	
	@Check
	def checaVariavelNaoInicializadaAssignment(assignment_statement assignment) {
		var element = assignment.variable.name;
		if (!variables.containsKey(element)) {
			error("Identifier not found " + element, null);
		}
	}
	
	@Check
	def checaIdsFactorExpressions(factor f) {
		if (!variables.containsKey(f.variable.name)) {
			error("Identifier not found " + f.variable.name, null);
		}
	}
	
	@Check
	def checaTipoSimples(type t) {
		if (t.simple !== null) {
			if (!t.simple.name.equals("boolean") && !t.simple.name.equals("integer") && !t.simple.name.equals("string")) {
				error("Invalid type", null);
			}
		}
	}
		
			
	@Check
	def restart(program program) {
		artefacts.clear();
		variables.clear();
		functions.clear();
		records.clear();
		types.clear();
	}
}
